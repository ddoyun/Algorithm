// 문제
// 1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요.
// 소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다.
// (1은 소수가 아닙니다.)

// 제한 조건
// n은 2이상 1000000이하의 자연수입니다.

// 입출력
// n	result
// 10	4
// 5	3

// 처음 풀이
function solution(n) {
  const num = (x) => {
      for (let i = 2; i <= Math.sqrt(x); i++) {
          if (x % i === 0) return false;
      }
      return true;
  }

  let count = 0;
  for (let i = 2; i <= n; i++) {
      if (num(i)) count++;
  }
}  

// 소수를 판별해주는 함수를 만들고, 매개변수 x 의 제곱근이 i로 나눠서 나머지가 0이면 false를 반환하도록 만들었다.
// 그리고 밑의 for문에서는 매개변수로 i값을 주어서 판별하게 하였는데, 코드 실행은 되었지만 
// 효율성 테스트는 실패하였다... 그래서 소수찾는 효율적인 방향이 없나 검색중에, 에라토스테네스의 체를 이용하면
// 쉽게 풀수 있다는 말에 한번 도입을 해보았다. 에라토스테네스의 체는 한마디로 노가다로 소수를 찾는 방식인데,
// 소수의 특징이 자신과 1로만 나눠 떨어지기 때문에 작은 배수들을 지우고 지우다 보면 언젠가 소수들만 남는 특성을 이용한 개념이다.

// 개선된 풀이
function solution(n) {
  let arr = [];
  let count = 0;
  
  for(let i = 2; i <= n; i++) {
      arr[i] = i;
  }

  for(let i = 2; i <= n; i++) {
      if(arr[i] === 0) continue; count++;

      for(let j = i * 2; j <= n; j += i) {
          arr[j] = 0;
      }
  }
return count;
}

// 먼저 1과 0은 제외가 되니 2부터 for문을 돌려 배열에 담았다.
// 그리고 아래에 소수인지 판별해주는 for문을 만들어 각 i값의 배수들을 0으로 지정한다.
// 여기서 2의 배수들이 0이 되고, 3의 배수들이 0이 된다.
// 그리고 위의 if문에서 i값이 0일때 count를 올려준다.
// 최종적으로 for문이 다 돌게 되면 0이 아닌 배열의 i의 개수가 count에 담긴다.

